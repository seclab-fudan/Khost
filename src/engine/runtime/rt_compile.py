# This file should be called by CMAKE. Do NOT directly run!
import os
import sys
import shutil


"""
- runtime
    - rt_compile.py
    - build: cmake build directory
    - guest: source code of the runtime which will be loaded into the vitual machine
    - host: bytes of the runtime which is stored in the host binary (auto generated by this script)
"""
# /runtime
RT_PATH           = os.path.dirname(__file__)
# /runtime/guest
RT_GUEST_PATH     = os.path.join(RT_PATH, "guest")
# /runtime/guest
RT_GUEST_SRC_PATH = os.path.join(RT_GUEST_PATH, ".")
# /runtime/guest/include
RT_GUEST_INC_PATH = os.path.join(RT_GUEST_PATH, "include")
# /runtime/host
RT_HOST_PATH      = os.path.join(RT_PATH, "host")
# /runtime/host
RT_HOST_SRC_PATH  = os.path.join(RT_HOST_PATH, ".")
# /runtime/host/include
RT_HOST_INC_PATH  = os.path.join(RT_HOST_PATH, "include")
# /runtime/build
RT_BUILD_PATH     = os.path.join(RT_PATH, "build")

for p in [ RT_HOST_PATH, RT_HOST_SRC_PATH, RT_HOST_INC_PATH, RT_BUILD_PATH ]:
    if not os.path.exists(p):
        try:
            os.mkdir(p)
        except Exception:
            pass


def error_and_exit(msg: str):
    print(msg)
    exit(-1)


class Compiler:

    def __init__(self, build_type: str, build_version: str, use_apt: str):
        """ init compiler with sepecific type """

        if build_type not in ["full", "para"]:
            error_and_exit(f"build type {build_type} unknown")
        self.build_type = build_type
        
        if build_version not in ["normal", "debug"]:
            error_and_exit(f"build version {version} unknown")
        self.build_version = build_version
        
        if use_apt not in ["ON", "OFF"]:
            error_and_exit(f"apt option {use_apt} unknown")
        self.use_apt = use_apt

        self.bin_size = 0

        # init path
        self.build_path = os.path.join(RT_BUILD_PATH, f"{build_type}_{build_version}_build")
        self.bin_path = os.path.join(self.build_path, f"{build_type}_{build_version}_runtime.bin")
        self.map_path = os.path.join(self.build_path, f"{build_type}_{build_version}_runtime.map")
        self.gen_c_path = os.path.join(RT_HOST_SRC_PATH, f"autogen_rt_{build_type}_{build_version}.cpp")
        self.gen_h_path = os.path.join(RT_HOST_INC_PATH, f"autogen_rt_{build_type}_{build_version}.h")

        # clean
        if os.path.exists(self.build_path):
            shutil.rmtree(self.build_path)
        [ os.remove(p) for p in [self.gen_c_path, self.gen_h_path] if os.path.exists(p) ]

        # check build dir
        if not os.path.exists(self.build_path):
            os.mkdir(self.build_path)

    
    def compile(self):
        """ compile the runtime """
        
        # working in /runtime/build/{build_type}_{build_version}_build
        os.chdir(self.build_path)

        # cmake
        if os.system(f"cmake ../../guest -DPROFILE={self.build_type} -DVERSION={self.build_version} -DUSE_APT={self.use_apt}") != 0:
            error_and_exit("failed to run cmake for runtime")

        # make
        if os.system("make -j") != 0:
            error_and_exit("failed to run make for runtime")


    def autogen_c(self):
        """ generate .cpp source code """
        
        file = ""

        try:
            bin = open(self.bin_path, "rb")
            self.bin_size = os.path.getsize(self.bin_path)

            # include of the .c file
            file += '/* This file is auto generated. Do NOT touch! */\n'
            file += f'#include "autogen_rt_{self.build_type}_{self.build_version}.h"\n\n'
            
            # size of the binary
            file += f'unsigned int RT_{self.build_type.upper()}_binary_size = {hex(self.bin_size)};\n\n'
            
            # table of the hal functions
            hal_table = []
            try:
                map_file = open(self.map_path, "r")
                for line in map_file:
                    line_part = line.split()
                    if len(line_part) == 2:
                        try:
                            addr = int(line_part[0], 16)
                            symbol = line_part[1]
                            if symbol.startswith("HAL"):
                                hal_table.append((hex(addr), symbol[:]))
                        except:
                            pass
                map_file.close()
            except:
                error_and_exit("failed to open runtime mapping file")
            file += f"HalDescriptor RT_{self.build_type.upper()}_hal_table[] = " + "{\n"
            for hal_des in hal_table:
                file += "    { " + hal_des[0] + ', "' + hal_des[1] + '" },\n'
            file += '    { 0x00000000, "END_OF_TABLE" }\n'
            file += "};\n\n"

            # hex of the binary
            file += f'unsigned char RT_{self.build_type.upper()}_binary[] = ' + '{\n'

            cnt = 0
            line = "    "
            for i in range(self.bin_size):
                bin_byte = bin.read(1)
                line += "0x%02x" % bin_byte[0]
                if i < self.bin_size - 1:
                    line += ", "
                cnt += 1
                if cnt == 16:
                    cnt = 0
                    file += line + '\n'
                    line = "    "
            if cnt != 0:
                file += line + '\n'

            file += '};\n'
            bin.close()
        except:
            error_and_exit("failed to open runtime binary")
        
        try: 
            c_file = open(self.gen_c_path, "w")
            c_file.write(file)
            c_file.close()
        except:
            error_and_exit("failed to write autogen .cpp file")
    

    def autogen_h(self):
        """ generate .h header code """

        file  = "/* This file is auto generated. Do NOT touch! */\n\n"
        file += f"#ifndef RT_{self.build_type.upper()}_{self.build_version.upper()}_H\n"
        file += f"#define RT_{self.build_type.upper()}_{self.build_version.upper()}_H\n\n"
        file += '#include "data_def.h"\n'
        file += f"extern unsigned int RT_{self.build_type.upper()}_binary_size;\n"
        file += f"extern unsigned char RT_{self.build_type.upper()}_binary[{hex(self.bin_size)}];\n\n"
        file += f"extern HalDescriptor RT_{self.build_type.upper()}_hal_table[];\n\n"

        try:
            map_file = open(self.map_path, "r")
            for line in map_file:
                line_part = line.split()
                if len(line_part) == 2:
                    try:
                        addr = int(line_part[0], 16)
                        symbol = line_part[1]
                        if symbol.startswith("RUNTIME"):
                            file += f"#define RT_{self.build_type.upper()}_{symbol[8:]} {hex(addr)}\n"
                    except:
                        pass
            map_file.close()
        except:
            error_and_exit("failed to open runtime mapping file")

        file += "\n#endif\n"

        try:
            h_file = open(self.gen_h_path, "w")
            h_file.write(file)
            h_file.close()
        except:
            error_and_exit("failed to write autogen .h file")


def main():
    """
    Usage:
        rt_compile.py [normal, debug] [full, para] [ON, OFF]
    """

    if len(sys.argv) != 4:
        error_and_exit("command args error")

    compiler = Compiler(sys.argv[1], sys.argv[2], sys.argv[3])

    compiler.compile()
    compiler.autogen_c()
    compiler.autogen_h()

if __name__ == "__main__":
    main()
